/*******************************************************************************
 * Mission Control Technologies, Copyright (c) 2009-2012, United States Government
 * as represented by the Administrator of the National Aeronautics and Space 
 * Administration. All rights reserved.
 *
 * The MCT platform is licensed under the Apache License, Version 2.0 (the 
 * "License"); you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at 
 * http://www.apache.org/licenses/LICENSE-2.0.
 *
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT 
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the 
 * License for the specific language governing permissions and limitations under 
 * the License.
 *
 * MCT includes source code licensed under additional open source licenses. See 
 * the MCT Open Source Licenses file included with this distribution or the About 
 * MCT Licenses dialog available at runtime from the MCT Help menu for additional 
 * information. 
 *******************************************************************************/
/**
 * MCTDialogManager.java Aug 18, 2008
 * 
 * This code is property of the National Aeronautics and Space Administration
 * and was produced for the Mission Control Technologies (MCT) Project.
 * 
 */
package gov.nasa.arc.mct.gui.dialogs;

import gov.nasa.arc.mct.components.AbstractComponent;
import gov.nasa.arc.mct.context.GlobalContext;
import gov.nasa.arc.mct.gui.View;
import gov.nasa.arc.mct.lock.manager.LockManager;

import java.util.Map;
import java.util.Set;
import java.util.Map.Entry;

import javax.swing.JFrame;
import gov.nasa.arc.mct.gui.OptionBox;

public class MCTDialogManager {

    public static AboutDialog showAboutMCTDialog(JFrame parent) {
        AboutDialog dlg = new AboutDialog(parent);
        dlg.setVisible(true);
        return dlg;
    }
    
    /**
     * Launches the show commit confirmation dialog.
     * @param lockedManifestations
     * @return whether the component was successfully locked.
     */
    public static boolean showCommitConfirmationDialog(Set<View> lockedManifestations) {
        View firstManifestation = lockedManifestations.iterator().next();
        LockManager lockManager = GlobalContext.getGlobalContext().getLockManager();
        AbstractComponent manifestedComponent = firstManifestation.getManifestedComponent();
        String targetComponentId = manifestedComponent.getId();

        Object[] options = {
                "Commit",
                "Abort",
                "Cancel"
                };
        
        int answer = OptionBox.showOptionDialog(firstManifestation, 
                "<HTML><B>The user object" 
                        + " \"" + manifestedComponent.getDisplayName() + "\" " 
                        + "contains pending changes.</B><BR><BR>"
                        + "Please specify what you wish to do with the<BR>"
                        + "pending changes before locking."
                        + "</HTML>",
                "Closing the window",
                OptionBox.YES_NO_CANCEL_OPTION,
                OptionBox.QUESTION_MESSAGE,
                null,
                options, options[0]);
        
        switch(answer) {
        case OptionBox.YES_OPTION:
            lockManager.unlock(targetComponentId, lockedManifestations);
            return true;
        case OptionBox.NO_OPTION:
            lockManager.abort(targetComponentId, lockedManifestations);
            return true;
        default:
            return false;
        }
    }
    
    /**
     * Checks if targetManifestation has pending changes. If so, pops a dialog for users to decide whether
     * to abort/commit the changes. Otherwise, lock the component associated with targetManifestation w/o
     * popping the dialog.
     * 
     * @param targetManifestation the selected manifestation
     * @param lockMap contains a componentId-MCTViewManifestation map; this map is generated by GUIUtil.getLockedManifestations(...)
     * @param action a string for populating the text description for the dialog
     * @param widgetType a string for populating the text description for the dialog
     * @return whether the component was successfully locked.
     */
    public static boolean showUnlockedConfirmationDialog(View targetManifestation, Map<String, Set<View>> lockMap, String action, String widgetType) {
        LockManager lockManager = GlobalContext.getGlobalContext().getLockManager();

        boolean containsPendingTransactions = false;
        for (String key : lockMap.keySet()) {
            if (lockManager.hasPendingTransaction(key)) {
                containsPendingTransactions = true;
                break;
            }
        }
        
        if (!containsPendingTransactions) {
            for (Entry<String, Set<View>> entry : lockMap.entrySet()) {
                String key = entry.getKey();
                lockManager.unlock(key, entry.getValue());
            }
            return true;
        }
        
        Object[] options = {
                            "Commit & " + action,
                            "Don't Commit, But Do " + action, 
                            "Cancel the " + action
                           };


        int answer = OptionBox.showOptionDialog(targetManifestation, 
                "<HTML><B>The \"" + targetManifestation.getManifestedComponent().getDisplayName() + "\" " 
                        + widgetType + " has uncommitted changes.</B><BR><BR>"
                        + "If you " + action.toLowerCase() + " without committing, those changes will be permanently lost.<BR>"
                        + "Do you want to commit the changes to the " + widgetType + " before " + toAdjectiveVerb(action).toLowerCase() + "?"
                        + "</HTML>",
                getDialogTitle(action, widgetType),
                OptionBox.YES_NO_CANCEL_OPTION,
                OptionBox.WARNING_MESSAGE,
                null,
                options, options[0]);
        
        switch(answer) {
        case OptionBox.YES_OPTION:
            for (Entry<String, Set<View>> entry : lockMap.entrySet()) {
                lockManager.unlock(entry.getKey(), entry.getValue());
            }
            return true;
        case OptionBox.NO_OPTION:
            for (Entry<String, Set<View>> entry : lockMap.entrySet()) {
                lockManager.abort(entry.getKey(), entry.getValue());
            }
            return true;
        default:
            return false;
        }
    }

    private static String getDialogTitle(String action, String widgetType) {
        return toAdjectiveVerb(action) + " the " + widgetType;
    }
    
    private static String toAdjectiveVerb(String verb) {
        return (verb.charAt(verb.length() - 1) == 'e')
                    ? verb.substring(0, verb.length() - 1) + "ing"
                    : verb + "ing";
    }
    
}
